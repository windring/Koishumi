codepen分析

from https://codepen.io/akm2/pen/rHIsa
### work
1. init(440+-530+)

  1. 准备画布
  2. 添加事件处理
  3. 执行addParticle
  4. 初始化dat.GUI的一个对象gui
  5. 启动动画loop

2. addParticle(441)

  1. 初始化多个Particle(273)的对象，x，y参数随机，角度使用PARTICLE_RADIUS(328)，值为10.
  2. call成员函数addSpeed(286)，为成员变量_speed(278)添加一个值，_speed为一个Vector对象。
  3. 上述对象push到particles(339，Array)中。

3. new dat.GUI()

  1. dat.gui.js(https://github.com/dataarts/dat.gui)
  2. 启动一个gui变量控制器，控制粒子数量和重力点之间的引力关系

4. loop中的动画

  1. 看起来很奇怪的save和restore。先将画布铺为BACKGROUND_COLOR(rgba(11, 51, 56, 1)，326)，又铺为grad。然后将坐标系统恢复为此前的状态。
  2. 处理重力点。对每个重力点应用状态处理和render。
  3. 为粒子绘制更新专用的画布，主要操作为降低透明度(494)，以渐淡此前绘制的粒子。取出particles中的粒子，call update(290)，绘制短直线(512)。绘制粒子头(519)。将粒子画布绘制在主画布上(525)。

```
    1. 处理状态，其处理状态dragging、destroyed。drag方法(167)，更新坐标。当重力点爆破时，将其slice。
    2. 重力点的render(186)
      1. 爆破点不绘制。取出GravityPoint(130)中的particles，为_GravityPoint._speed(278)添加速度，添加的速度为sub、normalize、scale操作后的值。
      2. 计算缓冲半径、当前半径。
      3. 如果当前处理的重力点达到爆破条件，置状态为destroyed，调用_draw，并结束render。
      4. 取出GravityPoint(130)中的gravities，处理重力点合并、更新garea,gravity,distroyed,addSpeed,当前半径和缓冲半径。
      5. 当重力点间引力启用，更新重力点的speed
      6. call _draw
```

### 物理模型

1.Vector.normalize()

标准化。  
m=sqrt( x^2 + y^2 )  
if m!=0 x/=m，y/=m  

2.Vector.length()

获取向量长度。  
return sqrt( x^2 + y^2 )

3.Vector.scale(s)

x\*=s  
y\*=s

4.addSpeed(d)

call _speed.add(d)

5.add(v)

(v)x+=v.x  
(v)y+=v.y




    