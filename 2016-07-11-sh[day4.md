呐呐，好久不见。说点气人的话吧。以下是一堆黑心的吐槽。

...

好了，发泄完毕，画风转变。我应该也有做的不对的地方，非常抱歉。  

嗯，是一个低效率的，原始的，简单的，所谓分治的，矩阵乘法算法。从这里开始入手吧，排序什么的懒得动了。怎么感觉写这份花了一个学期啊。（家长满怀恶意地用没有busybox和shell天病的SSS把HHH和NNN换走了，追悔莫及。

> SQUARE-MATRIX_MULTIPLY_RECURSIVE  

<iframe id="likapl" frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&id=600347&auto=1&height=66"></iframe>
<style>#likapl{width:100%;}</style>

* 0x0|准备工作 

1.shell的数组，只有一维数组。这意味着要通过一维数组去模拟二维矩阵。这样。
```
c[x][y]=c[y*rows+x]
```
2.shell的返回值，似乎只允许返回2的上下八次方以内的整数。这就。。。总不能递归的时候返回一堆字符串再慢慢解析吧。。。还好，XXX提供的思想是操作数组下标。（但是怎么操作这个问题，我纠结了很久。
```
return 22 #订正一点，return返回返回值
exit 0    #exit返回程序状态码
```
3.全局变量和局部变量。在函数外裸声明的是全局变量，函数内也是。通过**local**方法声明局部变量。
```
function
{
local var1
}
```
4.传参注意。大括号${}中的计算式是不会被计算的，若需要传递计算式，使用$((...))。（嗯，对，我被这机制坑了）

* 0x1|输入

输入两个文件，以空格符和回车符界定的边长为 2^n 的相同规模的整数的可计算矩阵，**以回车符结束文件**(特变强调这一点是读取的机制，仔细看，否则可能会少读一行。
```
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

```
两个嵌套循环，逐行逐目read，存储至全局变量c1，c2。
```
while read line1
do
((hndex++))
for var in $line1;do
c1[${index}]=$var
((index++))
done
done<$1
```

* 0x2|矩阵合并

一位数组和二维数组的关系嘛，用直角坐标和极坐标比喻下吧，简单地处理一下即可。
```
_ADD()
{
#index1:c目标矩阵的起始填充下标
#index2:c的填充宽度
#index3:c1的起始填充下标
#index4:c2的起始填充下标
local o=$1
local p=$2
local r=$3
local s=$4
i=0
while (( i<p ))
do
j=0
while(( j<p ))
do
((c[o+i*w+j]=c[r+i*w+j]+c[s+i*w+j]))
((j++))
done
((i++))
done
}
```
大概需要从三个大方阵（忽然意识到这个只针对方阵。。。说矩阵有点自夸了。。。）中划分出三个小方阵。（简单的下标操作）

* 0x3|递归分治

可能把分治放在前面比较好，毕竟是先划分任务往下分，然后从尾巴收敛回来。（啊，我的想法果然很low，毕竟是很差劲的家伙。  
分治简单些，给下一层分配c1、c2的计算下标和目标函数的填充下标就好。因为是用一维数组模拟二维，所以传的参还要包括rows（宽度？高度？（哭笑脸））。提一下目标函数c的填充下标，在二维矩阵的视角就是当前矩阵划分为四个等规模矩阵的最左上角。（其实哪里都可以啦，关键是统一（无聊的话不统一也行啦，反正总有办法转换的））  
最棘手的是怎么收敛，啊。因为是不可能使用函数返回值的，最深一次的分治最深一层的收敛放到哪是个严肃的问题，内存开销搞不好就指数了。这个想了半学期。本来觉得回来之后用别的语言跑个可视化搞清楚机制，结果居然。。。苦思冥想了个大概。  
**倒着干**。从目标矩阵上考量，最深一次分治带来的是两个项，两个项合并成一个项之后，右边的项就没有价值了，**可以在下一次合并时使用其位置**。然后依次在其右边，下方，右下方，合并得三组二项，总的就是四份二项的合并。向上一层的收敛就把这层的四个合并项看作两个待合并项中的一个即可。（本来就是）好吧底气不是很足。这样考量的话，目标矩阵的边界需要仔细考虑下。这样的操作需要比理想目标多出1倍宽的空间。于是乎，操作时使用宽为二倍rows的矩阵（rows*(两倍rows））。输出时输出左边的r*r就行啦（鬼知道你的左边右边是什么（列个矩阵嘛。。。））
```
#kernel
_SR()
{
local n=$1 #rows
local a=$2 #c1读取下标
local b=$3 #c2读取下标
local m=$4 #cの目标下标
if((n==1));then
((c[m]=c1[a]*c2[b]))
else

((n=n/2))

_SR ${n} ${a} ${b} $((m))
_SR ${n} $((a+n)) $((b+w2*n)) $((n+m))
_ADD ${m} ${n} $((m)) $((n+m))

_SR ${n} ${a} $((b+n)) $((n+m))
_SR ${n} $((a+n)) $((b+w2*n+n)) $((n*2+m))
_ADD $((m+n)) ${n} $((n+m)) $((n*2+m))

_SR ${n} $((a+w1*n)) ${b} $((w*n+m))
_SR ${n} $((a+w1*n+n)) $((b+w2*n)) $((w*n+n+m))
_ADD $((m+n*w)) ${n}  $((w*n+m)) $((w*n+n+m))

_SR ${n} $((a+w1*n)) $((b+n)) $((w*n+n+m))
_SR ${n} $((a+w1*n+n)) $((b+w1*n+n)) $((w*n+n*2+m))
_ADD $((m+n*w+n)) ${n} $((w*n+n+m)) $((w*n+n*2+m))

fi
}
#_SR()和_ADD()的参数列表没统一稍稍有那么一点不高兴
```

* 0x4|输出

用了很low的while循环。shell输出到文件的话再简单不过了，直接`>>`管道过去，再也不用跟麻麻要句柄了。

* 0x5|结语

说真的，这个花了我好长时间，什么原因的有，可能比较笨吧。碎碎念：期末考考砸了。。。呜呜，好可惜，模拟考还好。这样的程度是绝对不行的，梦想之门！